# cache-cat说明文档

## 介绍

cache-cat是一个高性能的键值对缓存库，同时使用Raft协议确保高可用的同时确保数据的强一致性。

cache-cat想实现一个绝对高性能的基于raft协议容灾的缓存框架。相比于Redis，Memcache等缓存，Cache-cat能够保证不会丢失数据。在这方面定位最类似的是

[RedisLabs/redisraft: A Redis Module that make it possible to create a consistent Raft cluster from multiple Redis instances.](https://github.com/RedisLabs/redisraft)

但是该项目只是一个lab项目，官方也不推荐在生产环境下使用，并且上一次的更新时间已经在2023年7月了。

> 即便使用了Redis的各种集群策略。Redis仍然有可能丢数据，Redis的集群解决的是可用性问题，而不解决数据一致性问题。

相比于ETCD，Zookeeper，Consul这类更为人熟知的注册中心，他们同样使用共识算法。 并且能保证数据的可靠性。但他们的性能和延迟无法比肩cache-cat（相同环境默认设置下，cache-cat能实现160k/s的写入，而ETCD只有60k/s）。此外这些中间件由于设计之初并不是为了缓存设计，因此缺乏很多特性，如LRU，LFU淘汰策略，以及最大内存占用设置。

## 功能

cache-cat目前仍然在企划阶段，因此以下内容均为构想，并且在理论上完全能够实现。

对于许多小公司来说，你可能只想构建一个高可用的应用，而不想引入成吨的中间件服务。

理论上你可以使用cache-cat来做

- 服务发现（注册中心），配置中心：类似consul和Zookeeper的定位，作为注册和配置中心来进行实现。需客户端适配。
- 缓存：类似Redis，dragonfly，valkey的定位：缓存绝大部分是读取操作，在读取层面，cache-cat的性能不会弱于这些缓存。而写入操作（根据一份调研，大部分系统的读写比为95：5，并且缓存本身无法加速写操作）cache-cat仍然提供了150k+的每秒处理速度，对于绝大部分场景足够使用。
- 消息队列：许多消息队列在默认设置下都是会丢数据，如Kafka。而Rocketmq你可以通过修改默认参数来确保数据不丢失，但是这会大大影响吞吐量。（在4.5版本之后Rocketmq，也使用了raft协议，能找到的最好成绩是7w/s）。就像许多人会用Redis的list作为消息队列一样，你同样也可以对cache-cat做相同的是事情，唯一的区别是cache-cat不会丢数据。
- 分布式锁：类似Zookeeper和ETCD。但不同于Redis的分布式锁，Redis的分布式锁相对来说有更多问题（即便你使用的是Redlock：[Is Redlock safe? - ](https://antirez.com/news/101)）。

关于性能部分cache-cat会在功能完善后补全完整的benchmark。

## 一致性模型

> 一个常被人提起的一致性问题是关于缓存与数据库的双写一致性。
>
> [干货 | 携程最终一致和强一致性缓存实践](https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q)
>
> 这与数据库本身的一致性存在区别，而下文提到的一致性为数据库本身的一致性模型，而不是数据库与缓存的双写一致性模型。
>
> 简而言之，如果一次写入操作能被立即读取到最新写入的数据，则可以被看做强一致。（对外暴露的语义一定是单个状态机）
>
> 如果需要一段时间后才能读取到最新的数据，则可以被看作为最终一致性。

cache-cat是强一致的缓存库。但是仍然提供了俩种强一致性读取级别。

### LeaseRead（租约读取）

**机制**：领导者节点在获得租约期间，可以**直接本地处理读取请求**，无需与其它节点通信。

**一致性强度**：**稍弱于ReadIndex**，因为依赖于本地时钟和对“领导者租约依然有效”的判断。

**性能**：**延迟极低**，近乎本地读取的性能。

你需要假设系统内各个节点之间的时钟漂移可以忽略，并且需要定时同步时钟（这在大部分数据中心中并不算一个太难的假设）。

因此在大部分情况下我们推荐使用租约读取就完全足够了。

### ReadIndex（读索引）

**机制**：领导者每次处理读取请求前，**必须与集群中的大多数节点通信**，确认自己仍然是合法的领导者。

**一致性强度**：**强一致性保证**，确保了线性化读取。

**性能**：**有网络往返开销**，每次读取都需要与其它节点通信，延迟较高。

**关键特点**：不依赖时钟假设，通过明确的通信来保证领导权。

**适用场景**：对数据一致性有严格要求，不能容忍任何过期读取的应用程序。

### NormalRead（常规读取）

该读操作会直接发给从节点，并由从节点直接返回，因此一致性级别为：**最终一致性**

即：从节点最终会得到主节点的这部分数据。这对于绝大部分的场景是够用的。并且最终从节点一定会同步到该数据。通常这个延迟被控制在500ms以内。

调用常规读取能够有助于缓解主节点的压力。

## QA

您可能会好奇cahce-cat与以下框架的区别和关系，下文会一一解释。

问题：和Tikv有什么区别：

答：Tikv是一个使用raft-engine作为日志复制，rocketdb作为存储层的数据库实现 。但cache-cat为了性能，数据将不进行任何的持久化。

***

问题：Redis真的会丢数据吗，把每条数据写入磁盘，崩溃了还会丢吗？再加上集群策略呢？

答：丢数据分俩部分，当数据写入磁盘时你可以看做数据在磁盘上持久化了。然而即便把AOF的频率开到最高：每条都写立即写日志，redis的策略仍然是先回应请求再写磁盘，也就是说最坏的情况下会丢一条数据。这种情况下，节点也无法正常提供服务。另外一个部分，Redis的集群策略也是类似，先回复请求再同步给从节点。如果在回复请求后没来得及发给从节点就宕机，Redis选出新的主之后这条数据就会永远的丢失。

***

问题：Raft协议强制将数据写入磁盘并且通知从节点之后才能将数据返回。这是否与缓存的高效设计背道而驰？

答：准确的说Raft是将操作日志写入磁盘，Raft并不限定状态机的数据是存放在哪里的，在cacahe-cat中这部分数据是完全存放在内存中的（hashmap和其他数据结构）。如果要进行类比的化，可以将需要持久化的数据比作Redis的AOF日志。作为参考，Zookeeper的整个Znode树以及consul的键值对都是存储在内存中的。ETCD则是会将数据持久化到磁盘。
对于缓存而言，同步和刷盘操作会带来写操作的延迟提升，相比于相同实现的纯缓存库这是必然的。但对于读取操作无需进行任何额外的磁盘操作。我们认为缓存更关注的是读取延迟而不是写入延迟，并且我们认为这样做是值得的：用略高的写入延迟带来的是完全不会丢弃数据。


## Todo List
以下内容在未来中会添加，但在当前迭代中没有计划
支持io_uring
可视化界面（展示当前cache-cat的状态）




























